import {
    TIMELINE_FUTURE_SLICE_LOAD,
    TIMELINE_FUTURE_SLICE_LOAD_FAILED,
    TIMELINE_PAST_SLICE_LOAD,
    TIMELINE_PAST_SLICE_LOAD_FAILED,
    TIMELINE_SCROLLED,
    TIMELINE_PAST_SLICE_SET,
    TIMELINE_FUTURE_SLICE_SET
} from "state/timeline/actions";
import { GO_TO_PAGE } from "state/navigation/actions";
import { PAGE_TIMELINE } from "state/navigation/pages";

const initialState = {
    loadingFuture: false,
    loadingPast: false,
    before: Number.MAX_SAFE_INTEGER,
    after: Number.MAX_SAFE_INTEGER,
    postings: [],
    anchor: Number.MAX_SAFE_INTEGER,
    at: Number.MAX_SAFE_INTEGER
};

export default (state = initialState, action) => {
    switch (action.type) {
        case GO_TO_PAGE:
            if (action.payload.page === PAGE_TIMELINE) {
                const anchor = action.payload.details.at;
                if (anchor != null) {
                    if (anchor <= state.before && anchor > state.after) {
                        return {
                            ...state,
                            anchor
                        }
                    } else {
                        return {
                            ...state,
                            before: anchor,
                            after: anchor,
                            postings: [],
                            anchor,
                            at: anchor
                        }
                    }
                }
            }
            return state;

        case TIMELINE_PAST_SLICE_LOAD:
            return {
                ...state,
                loadingPast: true
            };

        case TIMELINE_PAST_SLICE_LOAD_FAILED:
            return {
                ...state,
                loadingPast: false
            };

        case TIMELINE_FUTURE_SLICE_LOAD:
            return {
                ...state,
                loadingFuture: true
            };

        case TIMELINE_FUTURE_SLICE_LOAD_FAILED:
            return {
                ...state,
                loadingFuture: false
            };

        case TIMELINE_PAST_SLICE_SET:
            if (action.payload.before >= state.after && action.payload.after < state.after) {
                let postings = state.postings.slice();
                action.payload.postings
                    .filter(p => p.moment <= state.after)
                    .forEach(p => postings.push(p));
                postings.sort((a, b) => b.moment - a.moment);
                return {
                    ...state,
                    loadingPast: false,
                    after: action.payload.after,
                    postings
                };
            } else {
                return {
                    ...state,
                    loadingPast: false
                };
            }

        case TIMELINE_FUTURE_SLICE_SET:
            if (action.payload.before > state.before && action.payload.after <= state.before) {
                let postings = state.postings.slice();
                action.payload.postings
                    .filter(p => p.moment > state.before)
                    .forEach(p => postings.push(p));
                postings.sort((a, b) => b.moment - a.moment);
                return {
                    ...state,
                    loadingFuture: false,
                    before: action.payload.before,
                    postings
                };
            } else {
                return {
                    ...state,
                    loadingFuture: false
                };
            }

        case TIMELINE_SCROLLED:
            return {
                ...state,
                at: action.payload.at
            };

        default:
            return state;
    }
}
