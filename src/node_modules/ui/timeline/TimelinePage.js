import React from 'react';
import { connect } from 'react-redux';

import { Page } from "ui/page/Page";
import { Loading } from "ui/control";
import Posting from "ui/timeline/Posting";
import { timelinePastSliceLoad, timelineScrolled } from "state/timeline/actions";
import { isAtTimelinePage } from "state/navigation/selectors";

class TimelinePage extends React.Component {

    constructor(props) {
        super(props);
        this.prevAt = Number.MAX_SAFE_INTEGER;

        this.onScroll = this.onScroll.bind(this);
        this.updateOnScroll();
        this.observeSentinelPast = this.observeSentinelPast.bind(this);
        this.loadPast = this.loadPast.bind(this);
        this.observerPast = new IntersectionObserver(this.loadPast, {rootMargin: "0% 0% 25% 0%"});
    }

    componentDidUpdate(prevProps, prevState, snapshot) {
        if (this.props.visible !== prevProps.visible) {
            this.updateOnScroll();
        }
    }

    updateOnScroll() {
        window.onscroll = this.props.visible ? this.onScroll : null;
        console.log("Setting window.onscroll" + (window.onscroll == null ? "false" : "true"));
    }

    onScroll() {
        const at = TimelinePage.getTopmostMoment();
        if (at !== this.prevAt) {
            this.props.timelineScrolled(at);
        }
        this.prevAt = at;

    }

    static getTopmostMoment() {
        const postings = document.getElementsByClassName("posting");
        for (let i = 0; i < postings.length; i++) {
            if (postings.item(i).getBoundingClientRect().top >= 0) {
                return parseInt(postings.item(i).dataset.moment);
            }
        }
        return Number.MAX_SAFE_INTEGER;
    }

    observeSentinelPast(sentinel) {
        if (sentinel == null) {
            this.observerPast.disconnect();
        } else if (this.props.after > 0) {
            this.observerPast.observe(sentinel);
        }
    }

    loadPast() {
        if (this.props.loadingPast || this.props.after <= 0) {
            return;
        }
        this.props.timelinePastSliceLoad();
    }

    render() {
        const {loadingPast, postings} = this.props;
        return (
            <Page>
                <h2>Timeline</h2>
                {postings.map(posting => <Posting key={posting.moment} posting={posting} />)}
                <div ref={this.observeSentinelPast} />
                <Loading active={loadingPast} />
            </Page>
        );
    }
}

export default connect(
    state => ({
        visible: isAtTimelinePage(state),
        loadingPast: state.timeline.loadingPast,
        before: state.timeline.before,
        after: state.timeline.after,
        postings: state.timeline.postings
    }),
    { timelinePastSliceLoad, timelineScrolled }
)(TimelinePage);
