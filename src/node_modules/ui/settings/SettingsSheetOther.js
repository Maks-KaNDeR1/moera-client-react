import React from 'react';
import { connect } from 'react-redux';
import { Form, withFormik } from 'formik';

import SettingsField from "ui/settings/SettingsField";
import SettingsButtons from "ui/settings/SettingsButtons";
import * as SettingTypes from "ui/settings/setting-types";
import { messageBox } from "state/messagebox/actions";

function toFieldName(name) {
    return name.replace(/\./g, "_");
}

class SettingsSheetOther extends React.PureComponent {

    componentDidUpdate(prevProps, prevState, snapshot) {
        if ((this.props.nodeValues.size > 0 && prevProps.nodeValues.size === 0)
            || (this.props.nodeMeta.size > 0 && prevProps.nodeMeta.size === 0)) {

            this.props.resetForm();
        }
    }

    render() {
        const {nodeValues, nodeMeta} = this.props;

        return (
            <Form>
                {[...nodeValues.keys()].sort().map(name =>
                    <SettingsField key={name} name={name} fieldName={toFieldName(name)} meta={nodeMeta.get(name)} />
                )}
                <SettingsButtons />
            </Form>
        );
    }

}

const settingsSheetOtherLogic = {

    mapPropsToValues(props) {
        const {nodeValues, nodeMeta} = props;

        if (nodeValues.size === 0 || nodeMeta.size === 0) {
            return {};
        }

        let values = {};
        nodeValues.forEach((value, name) => {
            const meta = nodeMeta.get(name);
            const type = meta ? meta.type : "string";
            values[toFieldName(name)] = SettingTypes.toValue(type, value);
        });
        return values;
    },

    handleSubmit(values, formik) {
        const {nodeValues, nodeMeta, messageBox} = formik.props;

        if (nodeValues.size === 0 || nodeMeta.size === 0) {
            formik.setSubmitting(false);
            return;
        }

        let hasErrors = false;
        nodeMeta.forEach((meta, name) => {
            if (!meta) {
                return;
            }
            const fieldName = toFieldName(name);
            const v = SettingTypes.validate(values[fieldName], meta.type, meta.modifiers);
            console.log(fieldName, v);
            formik.setFieldError(fieldName, v !== true ? v : null);
            if (v !== true) {
                hasErrors = true;
            }
        });
        if (hasErrors) {
            messageBox("Some settings have incorrect values.");
        }

        /*formik.props.composePost(
            formik.props.postingId, {
                bodySrc: values.body.trim(),
                bodySrcFormat: values.bodyFormat.trim(),
                publishAt: values.publishAtCustomized ? moment(values.publishAt).unix() : null
            }
        );*/
        formik.setSubmitting(false);
    }

};

export default connect(
    state => ({
        nodeValues: state.settings.node.values,
        nodeMeta: state.settings.node.meta
    }),
    { messageBox }
)(withFormik(settingsSheetOtherLogic)(SettingsSheetOther));
